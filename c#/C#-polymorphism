问题:
    子类从父类那里继承的方法是完全一致的，这样就体现不出子类的特性了
    
多态:
    解决问题:当子类从父类那里继承某个方法之后，但是子类对于这个方法有其不同的响应形式，

实现多态方式:
    使用虚方法+重写(少c#特有的)
    使用抽象方法+抽象类重写(多共性)
    使用接口实现(多面向接口编程)
    
方法1: 虚方法+重写:
    虚方法:可以被子类重写的方法称为的虚方法
    定义:
        访问修饰符virtual返回值类型方法名称(参数)
        {
            //方法体
        }
    重写:（重新写）子类继承父类后，对父类那里继承来的方法进行改造的过程
    定义:
        访问修饰符 override 返回值类型 方法名称(参数)
        {
            //方法体
        }

    实现多态步骤:
        在父类中把子类需要改造的方法定义成虚方法
        子类继承之后就可以对这个虚方法进行重写(改造+自己的特性)
        
方式2: 抽象类/抽象方法+重写
    抽象类:非常“抽象"的类
        解释:
            A:经过多次抽象得到的类一般是抽象类
            B:这个类没有实例化的必要不用new做爸爸的
        语法:
            abstract class 类名 {}
            注意:
                这个类就不能new了 专门用来被继承的
                抽象类中依然可以正常定义字段，属性，方法
    抽象方法:没有方法体的方法
        语法:
        访问修饰符 abstract 返回值类型 方法名称(参数);
        
        注意:
            A:抽象方法不能申明方法体
            B:抽象方法只做声明不做实现，做了一个定义
            C:非抽象子类继承之后必须强制重写父类的抽象方法
            D:抽象方法只能放在抽象中类

        实现多态步骤:
            A:把父类定义成抽象类,需要重写的改造方法写成抽象方法
            B:子类继承之后去重写父类的抽象方法,重写时加入自己的特性
            
对比:
    （一般都是用抽象类+抽象方法）
    虚方法：本身有方法体所以如果有共性操作可以用虚方法先放在父类的虚方法中，子类继承之后这部分代码可以复用
    抽象方法：父类有没有必要定义抽象类，使用抽象方法有强制约束的效果



封装: 写类
继承: 类与类关系 复用
多态: 继承之后 需要不一样体现

重写和重载有什么区别:
    重载: 同一个类中不同的方法之间名称相同参数不同
    重写: 子类中父类方法进行改造

设计原则: 对修改关闭 对扩展开放
